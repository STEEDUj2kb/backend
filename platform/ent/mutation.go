// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/STEEDUj2kb/platform/ent/dailygaol"
	"github.com/STEEDUj2kb/platform/ent/predicate"
	"github.com/STEEDUj2kb/platform/ent/study"
	"github.com/STEEDUj2kb/platform/ent/user"
	"github.com/STEEDUj2kb/platform/ent/weeklygaol"
	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDailyGaol  = "DailyGaol"
	TypeStudy      = "Study"
	TypeUser       = "User"
	TypeWeeklyGaol = "WeeklyGaol"
)

// DailyGaolMutation represents an operation that mutates the DailyGaol nodes in the graph.
type DailyGaolMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	todo          *string
	_done         *bool
	is_removed    *bool
	clearedFields map[string]struct{}
	study         *int
	clearedstudy  bool
	wgoal         *int
	clearedwgoal  bool
	done          bool
	oldValue      func(context.Context) (*DailyGaol, error)
	predicates    []predicate.DailyGaol
}

var _ ent.Mutation = (*DailyGaolMutation)(nil)

// dailygaolOption allows management of the mutation configuration using functional options.
type dailygaolOption func(*DailyGaolMutation)

// newDailyGaolMutation creates new mutation for the DailyGaol entity.
func newDailyGaolMutation(c config, op Op, opts ...dailygaolOption) *DailyGaolMutation {
	m := &DailyGaolMutation{
		config:        c,
		op:            op,
		typ:           TypeDailyGaol,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDailyGaolID sets the ID field of the mutation.
func withDailyGaolID(id int) dailygaolOption {
	return func(m *DailyGaolMutation) {
		var (
			err   error
			once  sync.Once
			value *DailyGaol
		)
		m.oldValue = func(ctx context.Context) (*DailyGaol, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DailyGaol.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDailyGaol sets the old DailyGaol of the mutation.
func withDailyGaol(node *DailyGaol) dailygaolOption {
	return func(m *DailyGaolMutation) {
		m.oldValue = func(context.Context) (*DailyGaol, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DailyGaolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DailyGaolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DailyGaolMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *DailyGaolMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DailyGaolMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DailyGaol entity.
// If the DailyGaol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyGaolMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DailyGaolMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DailyGaolMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DailyGaolMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DailyGaol entity.
// If the DailyGaol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyGaolMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DailyGaolMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTodo sets the "todo" field.
func (m *DailyGaolMutation) SetTodo(s string) {
	m.todo = &s
}

// Todo returns the value of the "todo" field in the mutation.
func (m *DailyGaolMutation) Todo() (r string, exists bool) {
	v := m.todo
	if v == nil {
		return
	}
	return *v, true
}

// OldTodo returns the old "todo" field's value of the DailyGaol entity.
// If the DailyGaol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyGaolMutation) OldTodo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTodo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTodo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTodo: %w", err)
	}
	return oldValue.Todo, nil
}

// ResetTodo resets all changes to the "todo" field.
func (m *DailyGaolMutation) ResetTodo() {
	m.todo = nil
}

// SetDone sets the "done" field.
func (m *DailyGaolMutation) SetDone(b bool) {
	m._done = &b
}

// Done returns the value of the "done" field in the mutation.
func (m *DailyGaolMutation) Done() (r bool, exists bool) {
	v := m._done
	if v == nil {
		return
	}
	return *v, true
}

// OldDone returns the old "done" field's value of the DailyGaol entity.
// If the DailyGaol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyGaolMutation) OldDone(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDone: %w", err)
	}
	return oldValue.Done, nil
}

// ResetDone resets all changes to the "done" field.
func (m *DailyGaolMutation) ResetDone() {
	m._done = nil
}

// SetIsRemoved sets the "is_removed" field.
func (m *DailyGaolMutation) SetIsRemoved(b bool) {
	m.is_removed = &b
}

// IsRemoved returns the value of the "is_removed" field in the mutation.
func (m *DailyGaolMutation) IsRemoved() (r bool, exists bool) {
	v := m.is_removed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRemoved returns the old "is_removed" field's value of the DailyGaol entity.
// If the DailyGaol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyGaolMutation) OldIsRemoved(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsRemoved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsRemoved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRemoved: %w", err)
	}
	return oldValue.IsRemoved, nil
}

// ResetIsRemoved resets all changes to the "is_removed" field.
func (m *DailyGaolMutation) ResetIsRemoved() {
	m.is_removed = nil
}

// SetStudyID sets the "study" edge to the Study entity by id.
func (m *DailyGaolMutation) SetStudyID(id int) {
	m.study = &id
}

// ClearStudy clears the "study" edge to the Study entity.
func (m *DailyGaolMutation) ClearStudy() {
	m.clearedstudy = true
}

// StudyCleared reports if the "study" edge to the Study entity was cleared.
func (m *DailyGaolMutation) StudyCleared() bool {
	return m.clearedstudy
}

// StudyID returns the "study" edge ID in the mutation.
func (m *DailyGaolMutation) StudyID() (id int, exists bool) {
	if m.study != nil {
		return *m.study, true
	}
	return
}

// StudyIDs returns the "study" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudyID instead. It exists only for internal usage by the builders.
func (m *DailyGaolMutation) StudyIDs() (ids []int) {
	if id := m.study; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudy resets all changes to the "study" edge.
func (m *DailyGaolMutation) ResetStudy() {
	m.study = nil
	m.clearedstudy = false
}

// SetWgoalID sets the "wgoal" edge to the WeeklyGaol entity by id.
func (m *DailyGaolMutation) SetWgoalID(id int) {
	m.wgoal = &id
}

// ClearWgoal clears the "wgoal" edge to the WeeklyGaol entity.
func (m *DailyGaolMutation) ClearWgoal() {
	m.clearedwgoal = true
}

// WgoalCleared reports if the "wgoal" edge to the WeeklyGaol entity was cleared.
func (m *DailyGaolMutation) WgoalCleared() bool {
	return m.clearedwgoal
}

// WgoalID returns the "wgoal" edge ID in the mutation.
func (m *DailyGaolMutation) WgoalID() (id int, exists bool) {
	if m.wgoal != nil {
		return *m.wgoal, true
	}
	return
}

// WgoalIDs returns the "wgoal" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WgoalID instead. It exists only for internal usage by the builders.
func (m *DailyGaolMutation) WgoalIDs() (ids []int) {
	if id := m.wgoal; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWgoal resets all changes to the "wgoal" edge.
func (m *DailyGaolMutation) ResetWgoal() {
	m.wgoal = nil
	m.clearedwgoal = false
}

// Where appends a list predicates to the DailyGaolMutation builder.
func (m *DailyGaolMutation) Where(ps ...predicate.DailyGaol) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DailyGaolMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DailyGaol).
func (m *DailyGaolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DailyGaolMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, dailygaol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dailygaol.FieldUpdatedAt)
	}
	if m.todo != nil {
		fields = append(fields, dailygaol.FieldTodo)
	}
	if m._done != nil {
		fields = append(fields, dailygaol.FieldDone)
	}
	if m.is_removed != nil {
		fields = append(fields, dailygaol.FieldIsRemoved)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DailyGaolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dailygaol.FieldCreatedAt:
		return m.CreatedAt()
	case dailygaol.FieldUpdatedAt:
		return m.UpdatedAt()
	case dailygaol.FieldTodo:
		return m.Todo()
	case dailygaol.FieldDone:
		return m.Done()
	case dailygaol.FieldIsRemoved:
		return m.IsRemoved()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DailyGaolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dailygaol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dailygaol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dailygaol.FieldTodo:
		return m.OldTodo(ctx)
	case dailygaol.FieldDone:
		return m.OldDone(ctx)
	case dailygaol.FieldIsRemoved:
		return m.OldIsRemoved(ctx)
	}
	return nil, fmt.Errorf("unknown DailyGaol field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DailyGaolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dailygaol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dailygaol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dailygaol.FieldTodo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTodo(v)
		return nil
	case dailygaol.FieldDone:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDone(v)
		return nil
	case dailygaol.FieldIsRemoved:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRemoved(v)
		return nil
	}
	return fmt.Errorf("unknown DailyGaol field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DailyGaolMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DailyGaolMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DailyGaolMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DailyGaol numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DailyGaolMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DailyGaolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DailyGaolMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DailyGaol nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DailyGaolMutation) ResetField(name string) error {
	switch name {
	case dailygaol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dailygaol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dailygaol.FieldTodo:
		m.ResetTodo()
		return nil
	case dailygaol.FieldDone:
		m.ResetDone()
		return nil
	case dailygaol.FieldIsRemoved:
		m.ResetIsRemoved()
		return nil
	}
	return fmt.Errorf("unknown DailyGaol field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DailyGaolMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.study != nil {
		edges = append(edges, dailygaol.EdgeStudy)
	}
	if m.wgoal != nil {
		edges = append(edges, dailygaol.EdgeWgoal)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DailyGaolMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dailygaol.EdgeStudy:
		if id := m.study; id != nil {
			return []ent.Value{*id}
		}
	case dailygaol.EdgeWgoal:
		if id := m.wgoal; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DailyGaolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DailyGaolMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DailyGaolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstudy {
		edges = append(edges, dailygaol.EdgeStudy)
	}
	if m.clearedwgoal {
		edges = append(edges, dailygaol.EdgeWgoal)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DailyGaolMutation) EdgeCleared(name string) bool {
	switch name {
	case dailygaol.EdgeStudy:
		return m.clearedstudy
	case dailygaol.EdgeWgoal:
		return m.clearedwgoal
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DailyGaolMutation) ClearEdge(name string) error {
	switch name {
	case dailygaol.EdgeStudy:
		m.ClearStudy()
		return nil
	case dailygaol.EdgeWgoal:
		m.ClearWgoal()
		return nil
	}
	return fmt.Errorf("unknown DailyGaol unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DailyGaolMutation) ResetEdge(name string) error {
	switch name {
	case dailygaol.EdgeStudy:
		m.ResetStudy()
		return nil
	case dailygaol.EdgeWgoal:
		m.ResetWgoal()
		return nil
	}
	return fmt.Errorf("unknown DailyGaol edge %s", name)
}

// StudyMutation represents an operation that mutates the Study nodes in the graph.
type StudyMutation struct {
	config
	op             Op
	typ            string
	id             *int
	started_at     *time.Time
	ended_at       *time.Time
	content        *string
	clearedFields  map[string]struct{}
	planner        *int
	clearedplanner bool
	dgoals         map[int]struct{}
	removeddgoals  map[int]struct{}
	cleareddgoals  bool
	wgoals         map[int]struct{}
	removedwgoals  map[int]struct{}
	clearedwgoals  bool
	done           bool
	oldValue       func(context.Context) (*Study, error)
	predicates     []predicate.Study
}

var _ ent.Mutation = (*StudyMutation)(nil)

// studyOption allows management of the mutation configuration using functional options.
type studyOption func(*StudyMutation)

// newStudyMutation creates new mutation for the Study entity.
func newStudyMutation(c config, op Op, opts ...studyOption) *StudyMutation {
	m := &StudyMutation{
		config:        c,
		op:            op,
		typ:           TypeStudy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStudyID sets the ID field of the mutation.
func withStudyID(id int) studyOption {
	return func(m *StudyMutation) {
		var (
			err   error
			once  sync.Once
			value *Study
		)
		m.oldValue = func(ctx context.Context) (*Study, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Study.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStudy sets the old Study of the mutation.
func withStudy(node *Study) studyOption {
	return func(m *StudyMutation) {
		m.oldValue = func(context.Context) (*Study, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StudyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StudyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StudyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStartedAt sets the "started_at" field.
func (m *StudyMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *StudyMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Study entity.
// If the Study object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudyMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *StudyMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetEndedAt sets the "ended_at" field.
func (m *StudyMutation) SetEndedAt(t time.Time) {
	m.ended_at = &t
}

// EndedAt returns the value of the "ended_at" field in the mutation.
func (m *StudyMutation) EndedAt() (r time.Time, exists bool) {
	v := m.ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old "ended_at" field's value of the Study entity.
// If the Study object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudyMutation) OldEndedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ClearEndedAt clears the value of the "ended_at" field.
func (m *StudyMutation) ClearEndedAt() {
	m.ended_at = nil
	m.clearedFields[study.FieldEndedAt] = struct{}{}
}

// EndedAtCleared returns if the "ended_at" field was cleared in this mutation.
func (m *StudyMutation) EndedAtCleared() bool {
	_, ok := m.clearedFields[study.FieldEndedAt]
	return ok
}

// ResetEndedAt resets all changes to the "ended_at" field.
func (m *StudyMutation) ResetEndedAt() {
	m.ended_at = nil
	delete(m.clearedFields, study.FieldEndedAt)
}

// SetContent sets the "content" field.
func (m *StudyMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *StudyMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Study entity.
// If the Study object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudyMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *StudyMutation) ResetContent() {
	m.content = nil
}

// SetPlannerID sets the "planner" edge to the User entity by id.
func (m *StudyMutation) SetPlannerID(id int) {
	m.planner = &id
}

// ClearPlanner clears the "planner" edge to the User entity.
func (m *StudyMutation) ClearPlanner() {
	m.clearedplanner = true
}

// PlannerCleared reports if the "planner" edge to the User entity was cleared.
func (m *StudyMutation) PlannerCleared() bool {
	return m.clearedplanner
}

// PlannerID returns the "planner" edge ID in the mutation.
func (m *StudyMutation) PlannerID() (id int, exists bool) {
	if m.planner != nil {
		return *m.planner, true
	}
	return
}

// PlannerIDs returns the "planner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlannerID instead. It exists only for internal usage by the builders.
func (m *StudyMutation) PlannerIDs() (ids []int) {
	if id := m.planner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlanner resets all changes to the "planner" edge.
func (m *StudyMutation) ResetPlanner() {
	m.planner = nil
	m.clearedplanner = false
}

// AddDgoalIDs adds the "dgoals" edge to the DailyGaol entity by ids.
func (m *StudyMutation) AddDgoalIDs(ids ...int) {
	if m.dgoals == nil {
		m.dgoals = make(map[int]struct{})
	}
	for i := range ids {
		m.dgoals[ids[i]] = struct{}{}
	}
}

// ClearDgoals clears the "dgoals" edge to the DailyGaol entity.
func (m *StudyMutation) ClearDgoals() {
	m.cleareddgoals = true
}

// DgoalsCleared reports if the "dgoals" edge to the DailyGaol entity was cleared.
func (m *StudyMutation) DgoalsCleared() bool {
	return m.cleareddgoals
}

// RemoveDgoalIDs removes the "dgoals" edge to the DailyGaol entity by IDs.
func (m *StudyMutation) RemoveDgoalIDs(ids ...int) {
	if m.removeddgoals == nil {
		m.removeddgoals = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.dgoals, ids[i])
		m.removeddgoals[ids[i]] = struct{}{}
	}
}

// RemovedDgoals returns the removed IDs of the "dgoals" edge to the DailyGaol entity.
func (m *StudyMutation) RemovedDgoalsIDs() (ids []int) {
	for id := range m.removeddgoals {
		ids = append(ids, id)
	}
	return
}

// DgoalsIDs returns the "dgoals" edge IDs in the mutation.
func (m *StudyMutation) DgoalsIDs() (ids []int) {
	for id := range m.dgoals {
		ids = append(ids, id)
	}
	return
}

// ResetDgoals resets all changes to the "dgoals" edge.
func (m *StudyMutation) ResetDgoals() {
	m.dgoals = nil
	m.cleareddgoals = false
	m.removeddgoals = nil
}

// AddWgoalIDs adds the "wgoals" edge to the WeeklyGaol entity by ids.
func (m *StudyMutation) AddWgoalIDs(ids ...int) {
	if m.wgoals == nil {
		m.wgoals = make(map[int]struct{})
	}
	for i := range ids {
		m.wgoals[ids[i]] = struct{}{}
	}
}

// ClearWgoals clears the "wgoals" edge to the WeeklyGaol entity.
func (m *StudyMutation) ClearWgoals() {
	m.clearedwgoals = true
}

// WgoalsCleared reports if the "wgoals" edge to the WeeklyGaol entity was cleared.
func (m *StudyMutation) WgoalsCleared() bool {
	return m.clearedwgoals
}

// RemoveWgoalIDs removes the "wgoals" edge to the WeeklyGaol entity by IDs.
func (m *StudyMutation) RemoveWgoalIDs(ids ...int) {
	if m.removedwgoals == nil {
		m.removedwgoals = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.wgoals, ids[i])
		m.removedwgoals[ids[i]] = struct{}{}
	}
}

// RemovedWgoals returns the removed IDs of the "wgoals" edge to the WeeklyGaol entity.
func (m *StudyMutation) RemovedWgoalsIDs() (ids []int) {
	for id := range m.removedwgoals {
		ids = append(ids, id)
	}
	return
}

// WgoalsIDs returns the "wgoals" edge IDs in the mutation.
func (m *StudyMutation) WgoalsIDs() (ids []int) {
	for id := range m.wgoals {
		ids = append(ids, id)
	}
	return
}

// ResetWgoals resets all changes to the "wgoals" edge.
func (m *StudyMutation) ResetWgoals() {
	m.wgoals = nil
	m.clearedwgoals = false
	m.removedwgoals = nil
}

// Where appends a list predicates to the StudyMutation builder.
func (m *StudyMutation) Where(ps ...predicate.Study) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StudyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Study).
func (m *StudyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StudyMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.started_at != nil {
		fields = append(fields, study.FieldStartedAt)
	}
	if m.ended_at != nil {
		fields = append(fields, study.FieldEndedAt)
	}
	if m.content != nil {
		fields = append(fields, study.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StudyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case study.FieldStartedAt:
		return m.StartedAt()
	case study.FieldEndedAt:
		return m.EndedAt()
	case study.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StudyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case study.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case study.FieldEndedAt:
		return m.OldEndedAt(ctx)
	case study.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown Study field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case study.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case study.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	case study.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown Study field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StudyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StudyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Study numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StudyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(study.FieldEndedAt) {
		fields = append(fields, study.FieldEndedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StudyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StudyMutation) ClearField(name string) error {
	switch name {
	case study.FieldEndedAt:
		m.ClearEndedAt()
		return nil
	}
	return fmt.Errorf("unknown Study nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StudyMutation) ResetField(name string) error {
	switch name {
	case study.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case study.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	case study.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown Study field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StudyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.planner != nil {
		edges = append(edges, study.EdgePlanner)
	}
	if m.dgoals != nil {
		edges = append(edges, study.EdgeDgoals)
	}
	if m.wgoals != nil {
		edges = append(edges, study.EdgeWgoals)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StudyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case study.EdgePlanner:
		if id := m.planner; id != nil {
			return []ent.Value{*id}
		}
	case study.EdgeDgoals:
		ids := make([]ent.Value, 0, len(m.dgoals))
		for id := range m.dgoals {
			ids = append(ids, id)
		}
		return ids
	case study.EdgeWgoals:
		ids := make([]ent.Value, 0, len(m.wgoals))
		for id := range m.wgoals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StudyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeddgoals != nil {
		edges = append(edges, study.EdgeDgoals)
	}
	if m.removedwgoals != nil {
		edges = append(edges, study.EdgeWgoals)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StudyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case study.EdgeDgoals:
		ids := make([]ent.Value, 0, len(m.removeddgoals))
		for id := range m.removeddgoals {
			ids = append(ids, id)
		}
		return ids
	case study.EdgeWgoals:
		ids := make([]ent.Value, 0, len(m.removedwgoals))
		for id := range m.removedwgoals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StudyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedplanner {
		edges = append(edges, study.EdgePlanner)
	}
	if m.cleareddgoals {
		edges = append(edges, study.EdgeDgoals)
	}
	if m.clearedwgoals {
		edges = append(edges, study.EdgeWgoals)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StudyMutation) EdgeCleared(name string) bool {
	switch name {
	case study.EdgePlanner:
		return m.clearedplanner
	case study.EdgeDgoals:
		return m.cleareddgoals
	case study.EdgeWgoals:
		return m.clearedwgoals
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StudyMutation) ClearEdge(name string) error {
	switch name {
	case study.EdgePlanner:
		m.ClearPlanner()
		return nil
	}
	return fmt.Errorf("unknown Study unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StudyMutation) ResetEdge(name string) error {
	switch name {
	case study.EdgePlanner:
		m.ResetPlanner()
		return nil
	case study.EdgeDgoals:
		m.ResetDgoals()
		return nil
	case study.EdgeWgoals:
		m.ResetWgoals()
		return nil
	}
	return fmt.Errorf("unknown Study edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op             Op
	typ            string
	id             *int
	uuid           *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	name           *string
	email          *string
	user_status    *int
	adduser_status *int
	user_role      *user.UserRole
	password_hash  *string
	clearedFields  map[string]struct{}
	studies        map[int]struct{}
	removedstudies map[int]struct{}
	clearedstudies bool
	done           bool
	oldValue       func(context.Context) (*User, error)
	predicates     []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *UserMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *UserMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *UserMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetUserStatus sets the "user_status" field.
func (m *UserMutation) SetUserStatus(i int) {
	m.user_status = &i
	m.adduser_status = nil
}

// UserStatus returns the value of the "user_status" field in the mutation.
func (m *UserMutation) UserStatus() (r int, exists bool) {
	v := m.user_status
	if v == nil {
		return
	}
	return *v, true
}

// OldUserStatus returns the old "user_status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserStatus: %w", err)
	}
	return oldValue.UserStatus, nil
}

// AddUserStatus adds i to the "user_status" field.
func (m *UserMutation) AddUserStatus(i int) {
	if m.adduser_status != nil {
		*m.adduser_status += i
	} else {
		m.adduser_status = &i
	}
}

// AddedUserStatus returns the value that was added to the "user_status" field in this mutation.
func (m *UserMutation) AddedUserStatus() (r int, exists bool) {
	v := m.adduser_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserStatus resets all changes to the "user_status" field.
func (m *UserMutation) ResetUserStatus() {
	m.user_status = nil
	m.adduser_status = nil
}

// SetUserRole sets the "user_role" field.
func (m *UserMutation) SetUserRole(ur user.UserRole) {
	m.user_role = &ur
}

// UserRole returns the value of the "user_role" field in the mutation.
func (m *UserMutation) UserRole() (r user.UserRole, exists bool) {
	v := m.user_role
	if v == nil {
		return
	}
	return *v, true
}

// OldUserRole returns the old "user_role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserRole(ctx context.Context) (v user.UserRole, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserRole: %w", err)
	}
	return oldValue.UserRole, nil
}

// ResetUserRole resets all changes to the "user_role" field.
func (m *UserMutation) ResetUserRole() {
	m.user_role = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// AddStudyIDs adds the "studies" edge to the Study entity by ids.
func (m *UserMutation) AddStudyIDs(ids ...int) {
	if m.studies == nil {
		m.studies = make(map[int]struct{})
	}
	for i := range ids {
		m.studies[ids[i]] = struct{}{}
	}
}

// ClearStudies clears the "studies" edge to the Study entity.
func (m *UserMutation) ClearStudies() {
	m.clearedstudies = true
}

// StudiesCleared reports if the "studies" edge to the Study entity was cleared.
func (m *UserMutation) StudiesCleared() bool {
	return m.clearedstudies
}

// RemoveStudyIDs removes the "studies" edge to the Study entity by IDs.
func (m *UserMutation) RemoveStudyIDs(ids ...int) {
	if m.removedstudies == nil {
		m.removedstudies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.studies, ids[i])
		m.removedstudies[ids[i]] = struct{}{}
	}
}

// RemovedStudies returns the removed IDs of the "studies" edge to the Study entity.
func (m *UserMutation) RemovedStudiesIDs() (ids []int) {
	for id := range m.removedstudies {
		ids = append(ids, id)
	}
	return
}

// StudiesIDs returns the "studies" edge IDs in the mutation.
func (m *UserMutation) StudiesIDs() (ids []int) {
	for id := range m.studies {
		ids = append(ids, id)
	}
	return
}

// ResetStudies resets all changes to the "studies" edge.
func (m *UserMutation) ResetStudies() {
	m.studies = nil
	m.clearedstudies = false
	m.removedstudies = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.uuid != nil {
		fields = append(fields, user.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.user_status != nil {
		fields = append(fields, user.FieldUserStatus)
	}
	if m.user_role != nil {
		fields = append(fields, user.FieldUserRole)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUUID:
		return m.UUID()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldUserStatus:
		return m.UserStatus()
	case user.FieldUserRole:
		return m.UserRole()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUUID:
		return m.OldUUID(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldUserStatus:
		return m.OldUserStatus(ctx)
	case user.FieldUserRole:
		return m.OldUserRole(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldUserStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserStatus(v)
		return nil
	case user.FieldUserRole:
		v, ok := value.(user.UserRole)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserRole(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.adduser_status != nil {
		fields = append(fields, user.FieldUserStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUserStatus:
		return m.AddedUserStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldUserStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserStatus(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUUID:
		m.ResetUUID()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldUserStatus:
		m.ResetUserStatus()
		return nil
	case user.FieldUserRole:
		m.ResetUserRole()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.studies != nil {
		edges = append(edges, user.EdgeStudies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeStudies:
		ids := make([]ent.Value, 0, len(m.studies))
		for id := range m.studies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedstudies != nil {
		edges = append(edges, user.EdgeStudies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeStudies:
		ids := make([]ent.Value, 0, len(m.removedstudies))
		for id := range m.removedstudies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstudies {
		edges = append(edges, user.EdgeStudies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeStudies:
		return m.clearedstudies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeStudies:
		m.ResetStudies()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// WeeklyGaolMutation represents an operation that mutates the WeeklyGaol nodes in the graph.
type WeeklyGaolMutation struct {
	config
	op            Op
	typ           string
	id            *int
	goal          *string
	score         *int
	addscore      *int
	nth           *int
	addnth        *int
	clearedFields map[string]struct{}
	dgaols        map[int]struct{}
	removeddgaols map[int]struct{}
	cleareddgaols bool
	study         *int
	clearedstudy  bool
	done          bool
	oldValue      func(context.Context) (*WeeklyGaol, error)
	predicates    []predicate.WeeklyGaol
}

var _ ent.Mutation = (*WeeklyGaolMutation)(nil)

// weeklygaolOption allows management of the mutation configuration using functional options.
type weeklygaolOption func(*WeeklyGaolMutation)

// newWeeklyGaolMutation creates new mutation for the WeeklyGaol entity.
func newWeeklyGaolMutation(c config, op Op, opts ...weeklygaolOption) *WeeklyGaolMutation {
	m := &WeeklyGaolMutation{
		config:        c,
		op:            op,
		typ:           TypeWeeklyGaol,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWeeklyGaolID sets the ID field of the mutation.
func withWeeklyGaolID(id int) weeklygaolOption {
	return func(m *WeeklyGaolMutation) {
		var (
			err   error
			once  sync.Once
			value *WeeklyGaol
		)
		m.oldValue = func(ctx context.Context) (*WeeklyGaol, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WeeklyGaol.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWeeklyGaol sets the old WeeklyGaol of the mutation.
func withWeeklyGaol(node *WeeklyGaol) weeklygaolOption {
	return func(m *WeeklyGaolMutation) {
		m.oldValue = func(context.Context) (*WeeklyGaol, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WeeklyGaolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WeeklyGaolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WeeklyGaolMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGoal sets the "goal" field.
func (m *WeeklyGaolMutation) SetGoal(s string) {
	m.goal = &s
}

// Goal returns the value of the "goal" field in the mutation.
func (m *WeeklyGaolMutation) Goal() (r string, exists bool) {
	v := m.goal
	if v == nil {
		return
	}
	return *v, true
}

// OldGoal returns the old "goal" field's value of the WeeklyGaol entity.
// If the WeeklyGaol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeeklyGaolMutation) OldGoal(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGoal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGoal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoal: %w", err)
	}
	return oldValue.Goal, nil
}

// ResetGoal resets all changes to the "goal" field.
func (m *WeeklyGaolMutation) ResetGoal() {
	m.goal = nil
}

// SetScore sets the "score" field.
func (m *WeeklyGaolMutation) SetScore(i int) {
	m.score = &i
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *WeeklyGaolMutation) Score() (r int, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the WeeklyGaol entity.
// If the WeeklyGaol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeeklyGaolMutation) OldScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds i to the "score" field.
func (m *WeeklyGaolMutation) AddScore(i int) {
	if m.addscore != nil {
		*m.addscore += i
	} else {
		m.addscore = &i
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *WeeklyGaolMutation) AddedScore() (r int, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ClearScore clears the value of the "score" field.
func (m *WeeklyGaolMutation) ClearScore() {
	m.score = nil
	m.addscore = nil
	m.clearedFields[weeklygaol.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *WeeklyGaolMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[weeklygaol.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *WeeklyGaolMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
	delete(m.clearedFields, weeklygaol.FieldScore)
}

// SetNth sets the "nth" field.
func (m *WeeklyGaolMutation) SetNth(i int) {
	m.nth = &i
	m.addnth = nil
}

// Nth returns the value of the "nth" field in the mutation.
func (m *WeeklyGaolMutation) Nth() (r int, exists bool) {
	v := m.nth
	if v == nil {
		return
	}
	return *v, true
}

// OldNth returns the old "nth" field's value of the WeeklyGaol entity.
// If the WeeklyGaol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeeklyGaolMutation) OldNth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNth: %w", err)
	}
	return oldValue.Nth, nil
}

// AddNth adds i to the "nth" field.
func (m *WeeklyGaolMutation) AddNth(i int) {
	if m.addnth != nil {
		*m.addnth += i
	} else {
		m.addnth = &i
	}
}

// AddedNth returns the value that was added to the "nth" field in this mutation.
func (m *WeeklyGaolMutation) AddedNth() (r int, exists bool) {
	v := m.addnth
	if v == nil {
		return
	}
	return *v, true
}

// ResetNth resets all changes to the "nth" field.
func (m *WeeklyGaolMutation) ResetNth() {
	m.nth = nil
	m.addnth = nil
}

// AddDgaolIDs adds the "dgaols" edge to the DailyGaol entity by ids.
func (m *WeeklyGaolMutation) AddDgaolIDs(ids ...int) {
	if m.dgaols == nil {
		m.dgaols = make(map[int]struct{})
	}
	for i := range ids {
		m.dgaols[ids[i]] = struct{}{}
	}
}

// ClearDgaols clears the "dgaols" edge to the DailyGaol entity.
func (m *WeeklyGaolMutation) ClearDgaols() {
	m.cleareddgaols = true
}

// DgaolsCleared reports if the "dgaols" edge to the DailyGaol entity was cleared.
func (m *WeeklyGaolMutation) DgaolsCleared() bool {
	return m.cleareddgaols
}

// RemoveDgaolIDs removes the "dgaols" edge to the DailyGaol entity by IDs.
func (m *WeeklyGaolMutation) RemoveDgaolIDs(ids ...int) {
	if m.removeddgaols == nil {
		m.removeddgaols = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.dgaols, ids[i])
		m.removeddgaols[ids[i]] = struct{}{}
	}
}

// RemovedDgaols returns the removed IDs of the "dgaols" edge to the DailyGaol entity.
func (m *WeeklyGaolMutation) RemovedDgaolsIDs() (ids []int) {
	for id := range m.removeddgaols {
		ids = append(ids, id)
	}
	return
}

// DgaolsIDs returns the "dgaols" edge IDs in the mutation.
func (m *WeeklyGaolMutation) DgaolsIDs() (ids []int) {
	for id := range m.dgaols {
		ids = append(ids, id)
	}
	return
}

// ResetDgaols resets all changes to the "dgaols" edge.
func (m *WeeklyGaolMutation) ResetDgaols() {
	m.dgaols = nil
	m.cleareddgaols = false
	m.removeddgaols = nil
}

// SetStudyID sets the "study" edge to the Study entity by id.
func (m *WeeklyGaolMutation) SetStudyID(id int) {
	m.study = &id
}

// ClearStudy clears the "study" edge to the Study entity.
func (m *WeeklyGaolMutation) ClearStudy() {
	m.clearedstudy = true
}

// StudyCleared reports if the "study" edge to the Study entity was cleared.
func (m *WeeklyGaolMutation) StudyCleared() bool {
	return m.clearedstudy
}

// StudyID returns the "study" edge ID in the mutation.
func (m *WeeklyGaolMutation) StudyID() (id int, exists bool) {
	if m.study != nil {
		return *m.study, true
	}
	return
}

// StudyIDs returns the "study" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudyID instead. It exists only for internal usage by the builders.
func (m *WeeklyGaolMutation) StudyIDs() (ids []int) {
	if id := m.study; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudy resets all changes to the "study" edge.
func (m *WeeklyGaolMutation) ResetStudy() {
	m.study = nil
	m.clearedstudy = false
}

// Where appends a list predicates to the WeeklyGaolMutation builder.
func (m *WeeklyGaolMutation) Where(ps ...predicate.WeeklyGaol) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WeeklyGaolMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WeeklyGaol).
func (m *WeeklyGaolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WeeklyGaolMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.goal != nil {
		fields = append(fields, weeklygaol.FieldGoal)
	}
	if m.score != nil {
		fields = append(fields, weeklygaol.FieldScore)
	}
	if m.nth != nil {
		fields = append(fields, weeklygaol.FieldNth)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WeeklyGaolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case weeklygaol.FieldGoal:
		return m.Goal()
	case weeklygaol.FieldScore:
		return m.Score()
	case weeklygaol.FieldNth:
		return m.Nth()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WeeklyGaolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case weeklygaol.FieldGoal:
		return m.OldGoal(ctx)
	case weeklygaol.FieldScore:
		return m.OldScore(ctx)
	case weeklygaol.FieldNth:
		return m.OldNth(ctx)
	}
	return nil, fmt.Errorf("unknown WeeklyGaol field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WeeklyGaolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case weeklygaol.FieldGoal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoal(v)
		return nil
	case weeklygaol.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case weeklygaol.FieldNth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNth(v)
		return nil
	}
	return fmt.Errorf("unknown WeeklyGaol field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WeeklyGaolMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, weeklygaol.FieldScore)
	}
	if m.addnth != nil {
		fields = append(fields, weeklygaol.FieldNth)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WeeklyGaolMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case weeklygaol.FieldScore:
		return m.AddedScore()
	case weeklygaol.FieldNth:
		return m.AddedNth()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WeeklyGaolMutation) AddField(name string, value ent.Value) error {
	switch name {
	case weeklygaol.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	case weeklygaol.FieldNth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNth(v)
		return nil
	}
	return fmt.Errorf("unknown WeeklyGaol numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WeeklyGaolMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(weeklygaol.FieldScore) {
		fields = append(fields, weeklygaol.FieldScore)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WeeklyGaolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WeeklyGaolMutation) ClearField(name string) error {
	switch name {
	case weeklygaol.FieldScore:
		m.ClearScore()
		return nil
	}
	return fmt.Errorf("unknown WeeklyGaol nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WeeklyGaolMutation) ResetField(name string) error {
	switch name {
	case weeklygaol.FieldGoal:
		m.ResetGoal()
		return nil
	case weeklygaol.FieldScore:
		m.ResetScore()
		return nil
	case weeklygaol.FieldNth:
		m.ResetNth()
		return nil
	}
	return fmt.Errorf("unknown WeeklyGaol field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WeeklyGaolMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.dgaols != nil {
		edges = append(edges, weeklygaol.EdgeDgaols)
	}
	if m.study != nil {
		edges = append(edges, weeklygaol.EdgeStudy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WeeklyGaolMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case weeklygaol.EdgeDgaols:
		ids := make([]ent.Value, 0, len(m.dgaols))
		for id := range m.dgaols {
			ids = append(ids, id)
		}
		return ids
	case weeklygaol.EdgeStudy:
		if id := m.study; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WeeklyGaolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddgaols != nil {
		edges = append(edges, weeklygaol.EdgeDgaols)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WeeklyGaolMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case weeklygaol.EdgeDgaols:
		ids := make([]ent.Value, 0, len(m.removeddgaols))
		for id := range m.removeddgaols {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WeeklyGaolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddgaols {
		edges = append(edges, weeklygaol.EdgeDgaols)
	}
	if m.clearedstudy {
		edges = append(edges, weeklygaol.EdgeStudy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WeeklyGaolMutation) EdgeCleared(name string) bool {
	switch name {
	case weeklygaol.EdgeDgaols:
		return m.cleareddgaols
	case weeklygaol.EdgeStudy:
		return m.clearedstudy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WeeklyGaolMutation) ClearEdge(name string) error {
	switch name {
	case weeklygaol.EdgeStudy:
		m.ClearStudy()
		return nil
	}
	return fmt.Errorf("unknown WeeklyGaol unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WeeklyGaolMutation) ResetEdge(name string) error {
	switch name {
	case weeklygaol.EdgeDgaols:
		m.ResetDgaols()
		return nil
	case weeklygaol.EdgeStudy:
		m.ResetStudy()
		return nil
	}
	return fmt.Errorf("unknown WeeklyGaol edge %s", name)
}
